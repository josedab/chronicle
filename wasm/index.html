<!DOCTYPE html>
<html>
<head>
    <title>Chronicle WASM Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; max-width: 1000px; margin: 50px auto; padding: 20px; }
        button { margin: 5px; padding: 10px 20px; cursor: pointer; border: none; border-radius: 4px; background: #0066cc; color: white; }
        button:hover { background: #0052a3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        pre { background: #f5f5f5; padding: 15px; overflow-x: auto; border-radius: 4px; max-height: 300px; }
        .output { margin-top: 20px; }
        .status { padding: 10px; border-radius: 4px; margin: 10px 0; }
        .status.connected { background: #d4edda; color: #155724; }
        .status.disconnected { background: #f8d7da; color: #721c24; }
        .chart-container { margin: 20px 0; max-height: 400px; }
        .controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 20px 0; }
        .stat-card { background: #f5f5f5; padding: 15px; border-radius: 4px; text-align: center; }
        .stat-card h3 { margin: 0 0 5px 0; color: #666; font-size: 0.9em; }
        .stat-card .value { font-size: 1.8em; font-weight: bold; color: #333; }
    </style>
</head>
<body>
    <h1>üìä Chronicle WASM Demo</h1>
    <p>Embedded time-series database running entirely in your browser via WebAssembly!</p>
    
    <div id="status" class="status disconnected">‚è≥ Loading WASM module...</div>
    
    <div class="controls">
        <button id="btnOpen" onclick="openDB()" disabled>Open Database</button>
        <button id="btnWrite" onclick="writeData()" disabled>Write Sample Data</button>
        <button id="btnQuery" onclick="queryData()" disabled>Query Data</button>
        <button id="btnClose" onclick="closeDB()" disabled>Close Database</button>
        <label style="margin-left: 20px;">
            <input type="checkbox" id="autoRefresh" onchange="toggleAutoRefresh()"> Auto-refresh (1s)
        </label>
    </div>
    
    <div class="stats">
        <div class="stat-card">
            <h3>Points Written</h3>
            <div class="value" id="statPoints">0</div>
        </div>
        <div class="stat-card">
            <h3>Queries Executed</h3>
            <div class="value" id="statQueries">0</div>
        </div>
        <div class="stat-card">
            <h3>Latest Value</h3>
            <div class="value" id="statLatest">--</div>
        </div>
    </div>
    
    <div class="chart-container">
        <canvas id="chart"></canvas>
    </div>
    
    <div class="output">
        <h3>Console Output:</h3>
        <pre id="output">Initializing Chronicle WASM...</pre>
    </div>
    
    <script src="wasm_exec.js"></script>
    <script>
        const go = new Go();
        let dbReady = false;
        let chart = null;
        let autoRefreshInterval = null;
        let stats = { points: 0, queries: 0 };
        
        // Initialize Chart.js
        const ctx = document.getElementById('chart').getContext('2d');
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'CPU Usage (server-0)',
                    data: [],
                    borderColor: '#0066cc',
                    backgroundColor: 'rgba(0, 102, 204, 0.1)',
                    fill: true,
                    tension: 0.3
                }, {
                    label: 'CPU Usage (server-1)',
                    data: [],
                    borderColor: '#28a745',
                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                    fill: true,
                    tension: 0.3
                }, {
                    label: 'CPU Usage (server-2)',
                    data: [],
                    borderColor: '#dc3545',
                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                    fill: true,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { beginAtZero: true, max: 100, title: { display: true, text: 'CPU %' } },
                    x: { title: { display: true, text: 'Time' } }
                },
                plugins: {
                    legend: { position: 'bottom' }
                }
            }
        });
        
        // Load WASM module
        WebAssembly.instantiateStreaming(fetch("chronicle.wasm"), go.importObject)
            .then((result) => {
                go.run(result.instance);
                log("‚úÖ Chronicle WASM loaded successfully!");
                setStatus("connected", "‚úÖ WASM module ready - Click 'Open Database' to start");
                document.getElementById("btnOpen").disabled = false;
            })
            .catch(err => {
                log("‚ùå Error loading WASM: " + err);
                setStatus("disconnected", "‚ùå Failed to load WASM: " + err.message);
            });
        
        function setStatus(type, msg) {
            const el = document.getElementById("status");
            el.className = "status " + type;
            el.textContent = msg;
        }
        
        function log(msg) {
            const el = document.getElementById("output");
            const time = new Date().toLocaleTimeString();
            el.textContent = `[${time}] ${msg}\n` + el.textContent;
            console.log(msg);
        }
        
        function updateStats() {
            document.getElementById("statPoints").textContent = stats.points.toLocaleString();
            document.getElementById("statQueries").textContent = stats.queries.toLocaleString();
        }
        
        async function openDB() {
            try {
                await chronicle.open("demo.db", {
                    bufferSize: 10000,
                    partitionDuration: "1h"
                });
                dbReady = true;
                log("üìÇ Database opened successfully!");
                setStatus("connected", "‚úÖ Database connected");
                document.getElementById("btnOpen").disabled = true;
                document.getElementById("btnWrite").disabled = false;
                document.getElementById("btnQuery").disabled = false;
                document.getElementById("btnClose").disabled = false;
            } catch (err) {
                log("‚ùå Error: " + err.message);
            }
        }
        
        async function writeData() {
            if (!dbReady) {
                log("‚ö†Ô∏è Please open the database first");
                return;
            }
            
            try {
                const points = [];
                const now = Date.now() * 1000000;
                
                for (let i = 0; i < 100; i++) {
                    for (let server = 0; server < 3; server++) {
                        points.push({
                            metric: "cpu_usage",
                            value: 30 + Math.random() * 50 + (server * 5),
                            tags: { host: "server-" + server },
                            timestamp: now - (i * 60000000000)
                        });
                    }
                }
                
                await chronicle.writeBatch(points);
                stats.points += points.length;
                updateStats();
                log("‚úçÔ∏è Written " + points.length + " points!");
                
                // Auto-query after write
                await queryData();
            } catch (err) {
                log("‚ùå Error: " + err.message);
            }
        }
        
        async function queryData() {
            if (!dbReady) {
                log("‚ö†Ô∏è Please open the database first");
                return;
            }
            
            try {
                // Query each server separately
                const servers = ['server-0', 'server-1', 'server-2'];
                const allData = [];
                
                for (let i = 0; i < servers.length; i++) {
                    const results = await chronicle.execute({
                        metric: "cpu_usage",
                        tags: { host: servers[i] },
                        limit: 20
                    });
                    allData.push(results || []);
                }
                
                stats.queries++;
                updateStats();
                
                // Update chart
                if (allData[0] && allData[0].length > 0) {
                    const labels = allData[0].slice(0, 20).map((p, i) => `T-${19-i}m`).reverse();
                    chart.data.labels = labels;
                    
                    for (let i = 0; i < 3; i++) {
                        const values = (allData[i] || []).slice(0, 20).map(p => p.value).reverse();
                        chart.data.datasets[i].data = values;
                    }
                    chart.update('none');
                    
                    // Update latest stat
                    const latest = allData[0][0]?.value?.toFixed(1) || '--';
                    document.getElementById("statLatest").textContent = latest + '%';
                }
                
                const totalPoints = allData.reduce((sum, d) => sum + (d?.length || 0), 0);
                log("üîç Queried " + totalPoints + " points from 3 servers");
            } catch (err) {
                log("‚ùå Error: " + err.message);
            }
        }
        
        function toggleAutoRefresh() {
            const enabled = document.getElementById("autoRefresh").checked;
            if (enabled && dbReady) {
                autoRefreshInterval = setInterval(async () => {
                    // Add new point
                    const now = Date.now() * 1000000;
                    const points = [];
                    for (let server = 0; server < 3; server++) {
                        points.push({
                            metric: "cpu_usage",
                            value: 30 + Math.random() * 50 + (server * 5),
                            tags: { host: "server-" + server },
                            timestamp: now
                        });
                    }
                    await chronicle.writeBatch(points);
                    stats.points += 3;
                    updateStats();
                    await queryData();
                }, 1000);
                log("üîÑ Auto-refresh enabled");
            } else if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                log("‚èπÔ∏è Auto-refresh disabled");
            }
        }
        
        async function closeDB() {
            if (!dbReady) {
                log("‚ö†Ô∏è Database not open");
                return;
            }
            
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                document.getElementById("autoRefresh").checked = false;
            }
            
            try {
                await chronicle.close();
                dbReady = false;
                log("üìÅ Database closed!");
                setStatus("disconnected", "‚ö´ Database disconnected");
                document.getElementById("btnOpen").disabled = false;
                document.getElementById("btnWrite").disabled = true;
                document.getElementById("btnQuery").disabled = true;
                document.getElementById("btnClose").disabled = true;
            } catch (err) {
                log("‚ùå Error: " + err.message);
            }
        }
    </script>
</body>
</html>
